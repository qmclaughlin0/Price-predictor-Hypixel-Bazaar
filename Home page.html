<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyblock Bazaar Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }

        body {
            background-color: #f0f2f5;
        }

        header {
            background-color: #1a1a1a;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .search-section {
            margin-bottom: 2rem;
        }

        #searchInput {
            width: 100%;
            padding: 0.5rem;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
        }

        .item-card {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .item-card h3 {
            margin-bottom: 0.5rem;
            color: #333;
        }

        .price-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .prediction {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }

        .trend-up {
            color: #4caf50;
        }

        .trend-down {
            color: #f44336;
        }
    </style>
</head>
<body>
    <header>
        <h1>Skyblock Bazaar Tracker</h1>
        <p>Track and Predict Bazaar Prices</p>
    </header>

    <div class="container">
        <section class="search-section">
            <input type="text" id="searchInput" placeholder="Search for items...">
        </section>

        <section class="items-grid">
            <!-- Template for item cards - Will be populated by JavaScript -->
            <div class="item-card">
                <h3>Example Item</h3>
                <div class="price-info">
                    <span>Buy Price:</span>
                    <span>1,000 coins</span>
                </div>
                <div class="price-info">
                    <span>Sell Price:</span>
                    <span>950 coins</span>
                </div>
                <div class="prediction">
                    <h4>Price Prediction</h4>
                    <p class="trend-up">↑ Expected to rise (10%)</p>
                </div>
            </div>
        </section>
    </div>

    <!-- Placeholder for future JavaScript -->
    <script>
        // TODO: Add functionality for:
        // 1. Fetching real-time bazaar data
async function fetchBazaarData() {
    try {
        const response = await fetch('http://localhost:3000/api/current');
        const data = await response.json();
        
        if (data.success) {
            return data.products;
        } else {
            throw new Error('Failed to fetch bazaar data');
        }
    } catch (error) {
        console.error('Error fetching bazaar data:', error);
        return null;
    }
}

async function fetchHistoricalData() {
    try {
        const response = await fetch('http://localhost:3000/api/history?hours=6');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching historical data:', error);
        return {};
    }
}

function updateBazaarDisplay(products) {
    const itemsGrid = document.querySelector('.items-grid');
    itemsGrid.innerHTML = ''; // Clear existing items

    for (const [productId, product] of Object.entries(products)) {
        const buyPrice = product.quick_status.buyPrice.toFixed(1);
        const sellPrice = product.quick_status.sellPrice.toFixed(1);
        
        const itemCard = document.createElement('div');
        itemCard.className = 'item-card';
        itemCard.innerHTML = `
            <h3>${formatProductName(productId)}</h3>
            <div class="price-info">
                <span>Buy Price:</span>
                <span>${numberWithCommas(buyPrice)} coins</span>
            </div>
            <div class="price-info">
                <span>Sell Price:</span>
                <span>${numberWithCommas(sellPrice)} coins</span>
            </div>
        `;
        
        itemsGrid.appendChild(itemCard);
    }
}

function formatProductName(productId) {
    return productId.split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
}

function numberWithCommas(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Update data every 30 seconds
async function startRealTimeUpdates() {
    await updateData();
    setInterval(updateData, 30000);
}

async function updateData() {
    const products = await fetchBazaarData();
    if (products) {
        updateBazaarDisplay(products);
    }
}

// Start real-time updates when page loads
document.addEventListener('DOMContentLoaded', startRealTimeUpdates);        
// 2. Implementing search functionality
function setupSearch() {
    const searchInput = document.getElementById('searchInput');
    
    searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const itemCards = document.querySelectorAll('.item-card');
        
        itemCards.forEach(card => {
            const itemName = card.querySelector('h3').textContent.toLowerCase();
            if (itemName.includes(searchTerm)) {
                card.style.display = 'block';
            } else {
                card.style.display = 'none';
            }
        });
    });
}

function updateBazaarDisplay(products) {
    const itemsGrid = document.querySelector('.items-grid');
    itemsGrid.innerHTML = ''; // Clear existing items

    for (const [productId, product] of Object.entries(products)) {
        const buyPrice = product.quick_status.buyPrice.toFixed(1);
        const sellPrice = product.quick_status.sellPrice.toFixed(1);
        const buyVolume = product.quick_status.buyVolume;
        const sellVolume = product.quick_status.sellVolume;
        
        const itemCard = document.createElement('div');
        itemCard.className = 'item-card';
        itemCard.innerHTML = `
            <h3>${formatProductName(productId)}</h3>
            <div class="price-info">
                <span>Buy Price:</span>
                <span>${numberWithCommas(buyPrice)} coins</span>
            </div>
            <div class="price-info">
                <span>Sell Price:</span>
                <span>${numberWithCommas(sellPrice)} coins</span>
            </div>
            <div class="price-info">
                <span>Buy Volume:</span>
                <span>${numberWithCommas(buyVolume)}</span>
            </div>
            <div class="price-info">
                <span>Sell Volume:</span>
                <span>${numberWithCommas(sellVolume)}</span>
            </div>
        `;
        
        itemsGrid.appendChild(itemCard);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    setupSearch();
    startRealTimeUpdates();
}); 
       
// 3. Price prediction algorithms
function predictPrice(historicalData) {
    const priceHistory = historicalData.map(data => data.price);
    const timeHistory = historicalData.map(data => data.timestamp);
    
    // Calculate moving averages
    const shortMA = calculateMovingAverage(priceHistory, 12); // 1 hour MA
    const longMA = calculateMovingAverage(priceHistory, 72);  // 6 hour MA
    
    // Calculate price momentum
    const momentum = calculateMomentum(priceHistory);
    
    // Calculate volume trend
    const volumeTrend = calculateVolumeTrend(historicalData);
    
    // Weighted prediction calculation
    const lastPrice = priceHistory[priceHistory.length - 1];
    const prediction = lastPrice * (
        0.4 * (shortMA / lastPrice) + 
        0.3 * (longMA / lastPrice) + 
        0.2 * momentum +
        0.1 * volumeTrend
    );
    
    return {
        predictedPrice: prediction,
        trend: prediction > lastPrice ? 'up' : 'down',
        confidence: calculateConfidence(prediction, lastPrice)
    };
}

function calculateMovingAverage(prices, period) {
    if (prices.length < period) return prices.reduce((a,b) => a + b, 0) / prices.length;
    return prices.slice(-period).reduce((a,b) => a + b, 0) / period;
}

function calculateMomentum(prices) {
    const recent = prices.slice(-12); // Last hour
    const first = recent[0];
    const last = recent[recent.length-1];
    return (last - first) / first + 1;
}

function calculateVolumeTrend(historicalData) {
    const recentVolumes = historicalData.slice(-24).map(data => data.volume); // Last 2 hours
    const volumeChange = (recentVolumes[recentVolumes.length-1] - recentVolumes[0]) / recentVolumes[0];
    return volumeChange + 1;
}

function calculateConfidence(predicted, actual) {
    const percentDiff = Math.abs((predicted - actual) / actual);
    return Math.max(0, 1 - percentDiff);
}

/* 
Price Prediction Algorithm Explanation:

1. Moving Averages (MA):
- Short-term (1 hour) and long-term (6 hour) moving averages track price trends
- Crossing of these averages can indicate trend reversals

2. Momentum:
- Measures price velocity over the last hour
- Higher momentum suggests stronger trends

3. Volume Trend:
- Analyzes trading volume changes over 2 hours
- Higher volume can validate price movements

4. Weighted Calculation:
- 40% weight on short-term MA
- 30% weight on long-term MA  
- 20% weight on momentum
- 10% weight on volume trend

5. Confidence Score:
- Based on deviation between prediction and current price
- Higher deviation = lower confidence

The algorithm combines technical indicators to generate price predictions with confidence levels.
*/        // 4. Real-time updates
async function updateDataWithPredictions() {
    const [products, historicalData] = await Promise.all([
        fetchBazaarData(),
        fetchHistoricalData()
    ]);
    
    if (products) {
        // Get predictions and sort products
        const productsWithPredictions = Object.entries(products).map(([productId, product]) => {
            const history = historicalData[productId] || [];
            const formattedHistory = history.map(row => ({
                price: row.buy_price,
                volume: row.buy_volume,
                timestamp: row.timestamp
            }));
            
            const prediction = formattedHistory.length >= 12 ? 
                predictPrice(formattedHistory) :
                { predictedPrice: product.quick_status.buyPrice, trend: 'neutral', confidence: 0 };
            
            return {
                productId,
                product,
                prediction
            };
        }).sort((a, b) => b.prediction.confidence - a.prediction.confidence);

        updateBazaarDisplayWithPredictions(productsWithPredictions);
    }
}

function updateBazaarDisplayWithPredictions(productsWithPredictions) {
    const itemsGrid = document.querySelector('.items-grid');
    itemsGrid.innerHTML = '';

    for (const {productId, product, prediction} of productsWithPredictions) {
        const buyPrice = product.quick_status.buyPrice.toFixed(1);
        const sellPrice = product.quick_status.sellPrice.toFixed(1);
        const buyVolume = product.quick_status.buyVolume;
        const sellVolume = product.quick_status.sellVolume;
        
        const predictedChange = ((prediction.predictedPrice - buyPrice) / buyPrice * 100).toFixed(1);
        const trendClass = prediction.trend === 'up' ? 'trend-up' : 'trend-down';
        
        const itemCard = document.createElement('div');
        itemCard.className = 'item-card';
        itemCard.innerHTML = `
            <h3>${formatProductName(productId)}</h3>
            <div class="price-info">
                <span>Buy Price:</span>
                <span>${numberWithCommas(buyPrice)} coins</span>
            </div>
            <div class="price-info">
                <span>Sell Price:</span>
                <span>${numberWithCommas(sellPrice)} coins</span>
            </div>
            <div class="price-info">
                <span>Buy Volume:</span>
                <span>${numberWithCommas(buyVolume)}</span>
            </div>
            <div class="price-info">
                <span>Sell Volume:</span>
                <span>${numberWithCommas(sellVolume)}</span>
            </div>
            <div class="prediction">
                <h4>Price Prediction (${(prediction.confidence * 100).toFixed(1)}% confidence)</h4>
                <p class="${trendClass}">
                    ${prediction.trend === 'up' ? '↑' : '↓'} 
                    Expected ${prediction.trend} (${predictedChange}%)
                </p>
            </div>
        `;
        
        itemsGrid.appendChild(itemCard);
    }
}

// Update data every 5 minutes
async function startRealTimeUpdates() {
    await updateDataWithPredictions();
    setInterval(updateDataWithPredictions, 300000);
}

document.addEventListener('DOMContentLoaded', () => {
    setupSearch();
    startRealTimeUpdates();
});    </script>
</body>
</html>